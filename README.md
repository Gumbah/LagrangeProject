Jakub - Throughout the number theory side of the code (2nd half) I have left fairly detailed dated comments about what I was doing at particular times during the project. I have also labelled individual theorems or parts of theorems that I have proved, so my contribution to the project can be easily seen. I committed to the github repository very frequently, often several times per day, which was far more than others in my group, but this does not mean at all that I have contributed more to the project, so please take this into account. I am very happy with my improvements as a LEAN user (LEANer? LEANist?) during the project, throughout the duration of the project I have been consistently improving my formalisation abilities such as formal rigour in proofs, tactic vocabulary and understanding some of the intricacies and quirks of LEAN; from my initial naïve attempts to use for loops to define my euclidean algorithm I feel like after every big proof my LEANing abilities have significantly improved. Looking back at my early code (most of the stuff from 2023), I almost cringe at my lack of understanding of what would be required to prove Bézout's lemma, and the restrictive methods I worked with, for example it took me far longer than I am proud to admit to be able to make good use of the `have` tactic (which has since become one of my favourites). The difference in my ability from the outset of the project is clear to see, not even from the aforementioned for loops, but for instance see the difference between an early theorem `bez_rec`, which took me days to prove, and something (that I consider far more impressive) like `zmod_mul_inv_eq_one_iff_coprime_n` or `my_zmod_unitsEquivCoprime` from much further into the project. Maybe the difference is less obvious to those with vastly better LEANing ability but at least to me it is night and day. I believe that learning how to use LEAN has greatly improved my rigour and logic when it comes to mathematical proof, it would not be an exaggeration to say that it has changed the way I think about proof in general. I think that LEAN abiliy will be a great asset for the future of my mathematical career, though it is often difficult and painful to work with, finally completing a big proof is a very rewarding feeling, and I am glad to have experienced it. Outside LEAN, I was quick to pick up from Rose (Gumbah on github) how to use the repository, and after only a few botched commits and installs in November I was the one helping others with using the website. Since November I have been working on the project off and on, unfortunately the group were not able to get as much as we would have liked completed over the holidays due to illness and family events, and most of our LEANing abilities were poor at best before the holidays that any progress at that time was extremely slow. This term, especially these past few weeks (evidently the looming deadline was a big incentive), we have been consistently working collaboratively to try to complete our initial goals, which Katie and I on the number theory side managed to do just a few days before the end of the project on 04/02/24 (today).

Katie - Starting off slow, I got to grips with both the coding and LEAN-specific programming through proving basic lemmas about coprimality, working up to Euclid's lemma. I learnt a lot from this, including many logic tactics that would have certainly reduced this section into just a few lemmas. I think my immediate improvement (i.e. results about the totient function and onwards) is clear, and so, while this section was not utilised in any major final theorems, it was vital to my practise in independent LEAN formalisation. After term started up again, it proved much easier to collaborate efforts towards a main goal with Jakub: after realising it was too difficult of a task for the Group Theory team to feasibly manage, I began to research into Mathlib's method of working up to Euler's totient theorem, and ruling out what we reasonably could or couldn't replicate independently. We came to an agreement that using the definition ZMod.val and a few smaller lemmas about ZMod.val - as well as some generic Fintype/set.card results - would keep the formalisation interesting and fun, but still challenging. I independently created a workaround to equate the Fintype.card and Finset.card components in order to formalise 'totient_eq_zmod_units_card', and spelled out the stepping stones towards the overall proof of how we could connect everything (from coprime lemmas, to modular inverses) on paper. At first it was hard working out what exactly we would need for the "crown jewel" isomorphism between Units (ZMod n) and {x // x ∈ (Finset.range n).filter n.Coprime}, since we were working with Jakub's inverse definition and I didn't know how many coersion and equating lemmas we would need in the end. When this became the final result we needed to prove, it was a great team effort to first of all understand the isomorphism creation and then to replicate it for our own (slightly different, but enough difference for LEAN to require a few extra days/weeks of conviction) fintypes. After this, it was clear that a great deal of our theorems were simply unneeded for the main result (albeit some crop up in surprising ways). Still, many of them offer a demonstration of skill that felt satisfying to build up to, and so I am reluctant to erase them in pursuit of a concise document. Fintype and Finset equivalence (as well as casting between norms) proved to be a consistent bane of my efforts, including trying to bring so many of our major results together to prove Wilson's Theorem. If I had started this earlier, I think it would have been possibly doable with a work-around method that fresh eyes would have spotted. Outside of my code, a lot of my efforts went into organising meet-ups - to ensure everyone was on the same page - and the aforementioned planning of structure for proving Euler's totient theorem. Unfortunately, I hadn't realised how clueless I was at committing through VSCode with a GitHub extension until returning for term 2 and finding that I was not synced with the master branch at all. Jakub (and sometimes Rose) helped a lot during times where it would take almost an hour each day to commit and sync - something that is especially tedious on Mac, for some reason. As of today, I can say I can commit without fault about 95% of the time :). What was once a demotivating reflection of very gradual skill gain, is now a satisfying rollercoaster of understanding the efforts that go into each part of formalisation, and I feel more than content towards my improvements over the course of this project, which is on top of a by-product of general developments in my logic skills.
